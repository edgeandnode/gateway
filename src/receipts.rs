use std::time::SystemTime;

use rand::RngCore;
use tap_core::{receipt::Receipt as TapReceipt, signed_message::EIP712SignedMessage};
use thegraph_core::{
    AllocationId,
    alloy::{
        dyn_abi::Eip712Domain,
        primitives::{Address, U256},
        signers::local::PrivateKeySigner,
    },
};

pub struct Receipt(EIP712SignedMessage<TapReceipt>);

impl Receipt {
    pub fn value(&self) -> u128 {
        self.0.message.value
    }

    pub fn allocation(&self) -> Address {
        self.0.message.allocation_id
    }

    pub fn serialize(&self) -> String {
        serde_json::to_string(&self.0).unwrap()
    }
}

pub struct ReceiptSigner {
    signer: PrivateKeySigner,
    domain: Eip712Domain,
}

impl ReceiptSigner {
    pub fn new(signer: PrivateKeySigner, chain_id: U256, verifying_contract: Address) -> Self {
        Self {
            signer,
            domain: Eip712Domain {
                name: Some("TAP".into()),
                version: Some("1".into()),
                chain_id: Some(chain_id),
                verifying_contract: Some(verifying_contract),
                salt: None,
            },
        }
    }

    pub fn create_receipt(&self, allocation: AllocationId, fee: u128) -> anyhow::Result<Receipt> {
        // Nonce generated with CSPRNG (ChaCha12), to avoid collision with receipts generated by
        // other gateway processes.
        // See https://docs.rs/rand/latest/rand/rngs/index.html#our-generators.
        let nonce = rand::rng().next_u64();

        let timestamp_ns = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap()
            .as_nanos()
            .try_into()
            .map_err(|_| anyhow::anyhow!("failed to convert timestamp to ns"))?;

        let receipt = TapReceipt {
            allocation_id: allocation.0.0.into(),
            timestamp_ns,
            nonce,
            value: fee,
        };
        let signed = EIP712SignedMessage::new(&self.domain, receipt, &self.signer)
            .map_err(|e| anyhow::anyhow!("failed to sign receipt: {:?}", e))?;

        Ok(Receipt(signed))
    }
}

#[cfg(test)]
mod tests {
    use thegraph_core::{
        allocation_id,
        alloy::{primitives::address, signers::local::PrivateKeySigner},
    };

    use super::*;

    #[test]
    fn create_receipt() {
        //* Given
        let secret_key = PrivateKeySigner::from_slice(&[0xcd; 32]).expect("invalid secret key");
        let signer = ReceiptSigner::new(
            secret_key,
            1.try_into().expect("invalid chain id"),
            address!("177b557b12f22bb17a9d73dcc994d978dd6f5f89"),
        );

        let allocation = allocation_id!("89b23fea4e46d40e8a4c6cca723e2a03fdd4bec2");
        let fee = 1000;

        //* When
        let res = signer.create_receipt(allocation, fee);

        //* Then
        let receipt = res.expect("failed to create tap receipt");

        assert_eq!(receipt.value(), fee);
    }
}
