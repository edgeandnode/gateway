use std::{
    collections::HashMap,
    sync::Arc,
    time::{Duration, SystemTime},
};

use alloy_primitives::{Address, U256};
use alloy_sol_types::Eip712Domain;
use ethers::{core::k256::ecdsa::SigningKey, signers::Wallet};
use gateway_common::ttl_hash_map::TtlHashMap;
use rand::RngCore;
pub use receipts::QueryStatus as ReceiptStatus;
use receipts::ReceiptPool;
use secp256k1::SecretKey;
use tap_core::{receipt::Receipt, signed_message::EIP712SignedMessage};
use thegraph_core::types::DeploymentId;
use tokio::sync::{Mutex, RwLock};

pub enum ScalarReceipt {
    Legacy(u128, Vec<u8>),
    TAP(EIP712SignedMessage<Receipt>),
}

impl ScalarReceipt {
    pub fn grt_value(&self) -> u128 {
        match self {
            ScalarReceipt::Legacy(value, _) => *value,
            ScalarReceipt::TAP(receipt) => receipt.message.value,
        }
    }

    pub fn allocation(&self) -> Address {
        match self {
            ScalarReceipt::Legacy(_, receipt) => Address::from_slice(&receipt[0..20]),
            ScalarReceipt::TAP(receipt) => receipt.message.allocation_id,
        }
    }

    pub fn serialize(&self) -> String {
        match self {
            ScalarReceipt::Legacy(_, receipt) => hex::encode(&receipt[..(receipt.len() - 32)]),
            ScalarReceipt::TAP(receipt) => serde_json::to_string(&receipt).unwrap(),
        }
    }
}

/// Scalar TAP signer.
struct TapSigner {
    signer: Wallet<SigningKey>,
    domain: Eip712Domain,
}

impl TapSigner {
    /// Creates a new `TapSigner`.
    fn new(signer: SecretKey, chain_id: U256, verifying_contract: Address) -> Self {
        let signer = Wallet::from_bytes(signer.as_ref()).expect("failed to prepare receipt wallet");

        Self {
            signer,
            domain: Eip712Domain {
                name: Some("TAP".into()),
                version: Some("1".into()),
                chain_id: Some(chain_id),
                verifying_contract: Some(verifying_contract),
                salt: None,
            },
        }
    }

    /// Creates a new receipt for the given allocation and fee.
    fn create_receipt(
        &self,
        allocation: Address,
        fee: u128,
    ) -> anyhow::Result<EIP712SignedMessage<Receipt>> {
        // Nonce generated with CSPRNG (ChaCha12), to avoid collision with receipts generated by
        // other gateway processes.
        // See https://docs.rs/rand/latest/rand/rngs/index.html#our-generators.
        let nonce = rand::thread_rng().next_u64();

        let timestamp_ns = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap()
            .as_nanos()
            .try_into()
            .map_err(|_| anyhow::anyhow!("failed to convert timestamp to ns"))?;

        let receipt = Receipt {
            allocation_id: allocation.0 .0.into(),
            timestamp_ns,
            nonce,
            value: fee,
        };
        let signed = EIP712SignedMessage::new(&self.domain, receipt, &self.signer)
            .map_err(|e| anyhow::anyhow!("failed to sign receipt: {:?}", e))?;

        Ok(signed)
    }
}

/// Legacy Scalar signer.
struct LegacySigner {
    secret_key: &'static SecretKey,
    receipt_pools: RwLock<TtlHashMap<Address, Arc<Mutex<ReceiptPool>>>>,
}

impl LegacySigner {
    /// Creates a new `LegacySigner`.
    fn new(secret_key: &'static SecretKey) -> Self {
        let legacy_pool_ttl = Duration::from_secs(12 * 60 * 60); // 12 hours

        Self {
            secret_key,
            receipt_pools: RwLock::new(TtlHashMap::with_ttl(legacy_pool_ttl)),
        }
    }

    /// Creates a new receipt for the given allocation and fee.
    async fn create_receipt(
        &self,
        allocation: Address,
        fee: u128,
    ) -> anyhow::Result<(u128, Vec<u8>)> {
        // If the pool for the allocation exists, use it. Otherwise, create a new pool.
        let receipt = match self.receipt_pools.read().await.get(&allocation).cloned() {
            Some(pool) => {
                let mut pool = pool.lock().await;
                pool.commit(self.secret_key, 0.into())
            }
            None => {
                let mut pool = ReceiptPool::new(allocation.0 .0);
                let receipt = pool.commit(self.secret_key, 0.into());

                let mut write_guard = self.receipt_pools.write().await;
                write_guard.insert(allocation, Arc::new(Mutex::new(pool)));

                receipt
            }
        }
        .map_err(|e| anyhow::anyhow!("failed to sign legacy receipt: {:?}", e))?;

        Ok((fee, receipt))
    }

    /// Record the receipt status and release it from the pool.
    async fn record_receipt(&self, allocation: Address, receipt: &[u8], status: ReceiptStatus) {
        let legacy_pool = self.receipt_pools.read().await;
        if let Some(legacy_pool) = legacy_pool.get(&allocation) {
            legacy_pool.lock().await.release(receipt, status);
        };
    }
}

/// ReceiptSigner is responsible for creating receipts for indexing requests.
pub struct ReceiptSigner {
    tap: TapSigner,
    legacy: LegacySigner,

    /// Mapping of the largest allocation for each indexer-deployment pair.
    // TODO: Remove this once the network service is integrated and the largest allocation can be
    //  accessed via the `Indexing` instance.
    largest_allocations: RwLock<HashMap<(Address, DeploymentId), Address>>,
}

impl ReceiptSigner {
    /// Creates a new `ReceiptSigner`.
    pub async fn new(
        signer: SecretKey,
        chain_id: U256,
        verifier: Address,
        legacy_signer: &'static SecretKey,
    ) -> Self {
        Self {
            tap: TapSigner::new(signer, chain_id, verifier),
            legacy: LegacySigner::new(legacy_signer),
            largest_allocations: Default::default(),
        }
    }

    /// Creates a new Scalar TAP receipt for the given allocation and fee.
    // TODO: Return a Result instead of an Option.
    pub async fn create_receipt(
        &self,
        indexer: Address,
        deployment: DeploymentId,
        fee: u128,
    ) -> Option<ScalarReceipt> {
        // Get the largest allocation for the given indexer-deployment pair.
        // TODO: Remove this once the network service is integrated and the largest allocation can
        //  be accessed via the `Indexing` instance.
        let allocation = self
            .largest_allocations
            .read()
            .await
            .get(&(indexer, deployment))
            .cloned()?;

        self.tap
            .create_receipt(allocation, fee)
            .map(ScalarReceipt::TAP)
            .ok()
    }

    /// Creates a new Scalar legacy receipt for the given allocation and fee.
    // TODO: Return a Result instead of an Option.
    pub async fn create_legacy_receipt(
        &self,
        indexer: Address,
        deployment: DeploymentId,
        fee: u128,
    ) -> Option<ScalarReceipt> {
        // Get the largest allocation for the given indexer-deployment pair.
        // TODO: Remove this once the network service is integrated and the largest allocation can
        //  be accessed via the `Indexing` instance.
        let allocation = self
            .largest_allocations
            .read()
            .await
            .get(&(indexer, deployment))
            .cloned()?;

        self.legacy
            .create_receipt(allocation, fee)
            .await
            .map(|(fee, receipt)| ScalarReceipt::Legacy(fee, receipt))
            .ok()
    }

    /// Record the receipt status and release it from the pool.
    pub async fn record_receipt(
        &self,
        indexer: Address,
        deployment: DeploymentId,
        receipt: &ScalarReceipt,
        status: ReceiptStatus,
    ) {
        if let ScalarReceipt::Legacy(_, receipt) = receipt {
            // Get the largest allocation for the given indexer-deployment pair.
            // TODO: Remove this once the network service is integrated and the largest allocation
            //  can be accessed via the `Indexing` instance.
            let allocation = match self
                .largest_allocations
                .read()
                .await
                .get(&(indexer, deployment))
                .cloned()
            {
                Some(address) => address,
                None => return,
            };

            self.legacy
                .record_receipt(allocation, receipt, status)
                .await;
        }
    }

    /// Update the largest allocation for the given indexings (indexer-deployment pairs).
    pub async fn update_allocations(&self, indexings: &HashMap<(Address, DeploymentId), Address>) {
        let mut allocations = self.largest_allocations.write().await;
        allocations.retain(|k, _| indexings.contains_key(k));
        for (indexing, allocation) in indexings {
            allocations.insert(*indexing, *allocation);
        }
    }
}
