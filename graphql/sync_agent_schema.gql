type NetworkParameters {
  slashingPercentage: Float!
}

type Indexer {
  id: String!
  createdAt: Int
  url: String!
  stakedTokens: String!
  delegatedTokens: String!
}

type IndexersForDeployment {
  deployment: String!
  indexers: [Indexer!]!
}

type Allocation {
  id: String!
  creator: String!
  indexer: Indexer!
  subgraphDeploymentID: String!
  allocatedTokens: String!
  createdAt: Int!
  createdAtEpoch: Int!
}

type CurrentSubgraphDeployment {
  subgraph: String!
  deployment: String!
}

type SubgraphError {
  message: String!
}

type Block {
  number: Int!
  hash: String!
}

type IndexingStatus {
  indexer: Indexer!
  deployment: String!
  synced: Boolean!
  fatalError: SubgraphError
  network: String!
  block: Block
}

type IndexingStatusesForDeployment {
  deployment: String!
  statuses: [IndexingStatus!]!
}

type ConversionRates {
  daiToGrt: String
  grtToDai: String
}

type CostModel {
  deployment: String!
  indexer: Indexer!
  model: String
  variables: String
}

type CostModelsForDeployment {
  deployment: String!
  costModels: [CostModel!]!
}

type Transfer {
  id: String!
  indexer: Indexer!
  deployment: String!
  collateral: String!
  signerKey: String!
}

type ApiKeyInfo {
  id: Int!
  key: String!
  isSubsidized: Boolean!
  queryBudgetUSD: String!
  queryBudgetSelectionType: String!
}

type ApiKeyUserInfo {
  id: Int!
  ethAddress: String!
  queriesActivated: Boolean!
}

type ApiKeySubgraphInfo {
  id: Int!
  networkId: String!
}

type ApiKeyDomainInfo {
  id: Int!
  name: String!
}

type ApiKeyIndexerPreference {
  id: Int!
  name: String!
  description: String!
  weight: Float!
}

type ApiKey {
  apiKey: ApiKeyInfo!
  user: ApiKeyUserInfo!

  deployments: [String!]!

  subgraphs: [ApiKeySubgraphInfo!]!
  domains: [ApiKeyDomainInfo!]!
  indexerPreferences: [ApiKeyIndexerPreference!]!
}

type NetworkParametersResult {
  updateId: String!
  value: NetworkParameters!
}

type DeploymentsResult {
  updateId: String!
  value: [String!]!
}

type IndexersResult {
  updateId: String!
  value: [IndexersForDeployment!]!
}

type CurrentDeploymentsResult {
  updateId: String!
  value: [CurrentSubgraphDeployment!]!
}

type IndexingStatusesResult {
  updateId: String!
  value: [IndexingStatusesForDeployment!]!
}

type ConversionRatesResult {
  updateId: String!
  value: ConversionRates!
}

type CostModelsResult {
  updateId: String!
  value: [CostModelsForDeployment!]!
}

type TransfersResult {
  updateId: String!
  value: [Transfer!]!
}

type UsableAllocationsResult {
  updateId: String!
  value: [Allocation!]!
}

type ApiKeysResult {
  updateId: String!
  value: [ApiKey!]!
}

type Query {
  healthCheck: Boolean!

  "Returns null if there was no update since lastUpdateId"
  networkParameters(lastUpdateId: String!): NetworkParametersResult

  "Returns null if there was no update since lastUpdateId"
  deployments(lastUpdateId: String!): DeploymentsResult

  "Returns null if there was no update since lastUpdateId"
  indexers(lastUpdateId: String!): IndexersResult

  "Returns null if there was no update since lastUpdateId"
  currentDeployments(lastUpdateId: String!): CurrentDeploymentsResult

  "Returns null if there was no update since lastUpdateId"
  indexingStatuses(lastUpdateId: String!): IndexingStatusesResult

  "Returns null if there was no update since lastUpdateId"
  conversionRates(lastUpdateId: String!): ConversionRatesResult

  "Returns null if there was no update since lastUpdateId"
  costModels(lastUpdateId: String!): CostModelsResult

  "Returns null if there was no update since lastUpdateId"
  transfers(lastUpdateId: String!, gatewayId: String!): TransfersResult

  "Returns null if there was no update since lastUpdateId"
  usableAllocations(lastUpdateId: String!): UsableAllocationsResult

  # TODO: Syncing all API keys to all gateways whenever there is a change
  # is a naive approach that only works with a few hundred API keys.
  # It would be better to sync all API keys initially and then push only
  # changes to gateways.
  "Returns null if there was no update since lastUpdateId"
  apiKeys(lastUpdateId: String!): ApiKeysResult
}

type Mutation {
  createTransfer(indexer: String!, deployment: String!): Transfer!
  ensureTransfersForGateway(gatewayId: String!): [Transfer!]!
}
